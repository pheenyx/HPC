\documentclass[10pt,a4paper]{scrartcl}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[ngerman]{babel}
\usepackage{microtype, multicol, marginnote, bera, parskip}
\usepackage{listings, amsmath, amssymb, graphicx, tikz, epic}
\usepackage{stmaryrd} %for lightning arrow
\usepackage{pstricks, pst-node, pst-tree, pdflscape}
\usepackage[babel=true]{csquotes}
\tolerance=2000
\setcounter{secnumdepth}{0}
\usepackage[inner=2.5cm,outer=2.5cm,top=1.5cm,bottom=1.5cm,includeheadfoot]{geometry}

\author{Nils DÃ¶ring \and Michael Mardaus \and Julian F. Rost}
\title{High Performance Computing: Sheet 2}

\begin{document}

\maketitle


\section{Question 1}


\section{Question 2}
\subsection{a)}
The sequential fraction of a program is the part which can not be parallelized, such as initiation or termination of the program, communication between parts of the program and time used by synchronizing the different parts of the program running parallel. This sequential fraction can not be parallelized and does not speed up with the number of processors.

\section{Question 3}

\subsection{a)}
Another example of superlinear speedup:\\
If the algorithm is randomized and seraches a specific element in a datastructure, lets say a tree. The more processors that start to search at different enrtypoints of the tree, the faster they will succeed.

\subsection{b)}
\textit{An apparent alternative would be to identify aggregate tasks with elements of \texttt{bin\_counts}, so an aggregate task would consist of all
increments of \texttt{bin\_counts[b]} and consequently all calls to \texttt{find\_bin} that return \texttt{b}.}\\

In this idea we would split up the incrementation by 1 of some variable over multiple cores, whilst the much harder task to find the correct bin for each data piece (that needs to be incremented) remains the bottleneck of the function.

\end{document}
